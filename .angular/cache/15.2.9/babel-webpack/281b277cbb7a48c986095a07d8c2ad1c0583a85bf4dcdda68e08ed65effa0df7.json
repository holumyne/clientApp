{"ast":null,"code":"import { BehaviorSubject, map } from 'rxjs';\nimport { environment } from 'src/environments/environment';\nimport { Basket } from '../shared/models/basket';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let BasketService = /*#__PURE__*/(() => {\n  class BasketService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = environment.apiUrl;\n      this.basketSource = new BehaviorSubject(null); //this null means that when our app first start up b4 we done anything, we are not going to hv a basket and it will be null. other component will not hv access to this thats why its private. you can only update this from inside our service\n      this.basketSource$ = this.basketSource.asObservable(); //our component will be able to subscribe to this and get the info they want\n      this.basketTotalSource = new BehaviorSubject(null);\n      this.basketTotalSource$ = this.basketTotalSource.asObservable();\n    }\n    createPaymentIntent() {\n      return this.http.post(this.baseUrl + 'payments/' + this.getCurrentBasketValue()?.id, {}).pipe(map(basket => {\n        this.basketSource.next(basket);\n      }));\n    }\n    setShippingPrice(deliveryMethod) {\n      const basket = this.getCurrentBasketValue();\n      if (basket) {\n        basket.shippingPrice = deliveryMethod.price;\n        basket.deliveryMethodId = deliveryMethod.id;\n        this.setBasket(basket);\n      }\n    }\n    getBasket(id) {\n      return this.http.get(this.baseUrl + 'basket?id=' + id).subscribe({\n        next: basket => {\n          this.basketSource.next(basket);\n          this.calculateTotals();\n        }\n      });\n    }\n    setBasket(basket) {\n      return this.http.post(this.baseUrl + 'basket', basket).subscribe({\n        next: basket => {\n          this.basketSource.next(basket);\n          this.calculateTotals();\n        }\n      });\n    }\n    getCurrentBasketValue() {\n      return this.basketSource.value;\n    }\n    addItemToBasket(item, quantity = 1) {\n      if (this.isProduct(item)) item = this.mapProductItemToBasketItem(item); //type guard is used here referencing isProduct below\n      console.log(item);\n      const basket = this.getCurrentBasketValue() ?? this.createBasket();\n      basket.items = this.addOrUpdateItem(basket.items, item, quantity);\n      this.setBasket(basket);\n    }\n    removeItemFromBasket(id, quantity = 1) {\n      const basket = this.getCurrentBasketValue();\n      if (!basket) return; //if basket is empty, return nothing\n      const item = basket.items.find(x => x.id === id);\n      if (item) {\n        item.quantity -= quantity; //decrement\n        if (item.quantity === 0) {\n          //if its now equal to 0 after the decrement\n          basket.items = basket.items.filter(x => x.id !== id);\n        }\n        if (basket.items.length > 0) this.setBasket(basket);else this.deleteBasket(basket);\n      }\n    }\n    deleteBasket(basket) {\n      return this.http.delete(this.baseUrl + 'basket?id=' + basket.id).subscribe({\n        next: () => {\n          this.deleteLocalBasket();\n        }\n      });\n    }\n    deleteLocalBasket() {\n      this.basketSource.next(null);\n      this.basketTotalSource.next(null);\n      localStorage.removeItem('basket_id');\n    }\n    addOrUpdateItem(items, itemToAdd, quantity) {\n      const item = items.find(x => x.id === itemToAdd.id);\n      if (item) item.quantity += quantity; //increase the quantity if we have item in our basket\n      else {\n        itemToAdd.quantity = quantity;\n        items.push(itemToAdd);\n      }\n      return items;\n    }\n    createBasket() {\n      const basket = new Basket();\n      localStorage.setItem('basket_id', basket.id);\n      return basket;\n    }\n    mapProductItemToBasketItem(item) {\n      return {\n        id: item.id,\n        productName: item.name,\n        price: item.price,\n        quantity: 0,\n        pictureUrl: item.pictureUrl,\n        brand: item.productBrand,\n        type: item.productType\n      };\n    }\n    calculateTotals() {\n      const basket = this.getCurrentBasketValue();\n      if (!basket) return;\n      const subtotal = basket.items.reduce((a, b) => b.price * b.quantity + a, 0); //where a = previous value, b = current value. Any letter can be used for rep.\n      const total = subtotal + basket.shippingPrice;\n      this.basketTotalSource.next({\n        shipping: basket.shippingPrice,\n        total,\n        subtotal\n      });\n    }\n    isProduct(item) {\n      return item.productBrand !== undefined;\n    }\n  }\n  BasketService.ɵfac = function BasketService_Factory(t) {\n    return new (t || BasketService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  BasketService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BasketService,\n    factory: BasketService.ɵfac,\n    providedIn: 'root'\n  });\n  return BasketService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}